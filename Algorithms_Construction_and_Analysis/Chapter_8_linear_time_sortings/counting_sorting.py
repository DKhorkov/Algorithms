"""
Сортировка подсчетом работает за линейное время O(k + n), где n - длина сортируемого массива,
а k - наибольшее целое число в данном массиве.
Все элементы массива должны быть ЦЕЛЫМИ ПОЛОЖИТЕЛЬНЫМИ числами.

Также данная сортировка является УСТОЙЧИВОЙ - элементы с одним и тем же значением находятся в
выходном массиве в том же порядке, что и во входном.
"""

from typing import List


class CountingSorting:

    def __init__(self, arr: List[int]) -> None:
        self._arr: List[int] = arr
        self._k: int = max(self._arr)

    def sort(self) -> List[int]:
        """
        Временный массив для того, чтобы вести подсчет, сколько чисел во входном массиве больше, чем текущее.
        range(self._k + 1), поскольку в массиве может быть 0 согласно условию, а мы увеличиваем значение,
        описывающее сколько встретилось каждое число в массиве, обращаясь к индексу массива, равному числу
        (например 0 или максимальному числу в массиве k).
        """
        temp_arr: List[int] = [0 for _ in range(self._k + 1)]

        # Считаем сколько раз встретилось каждое число во входном массиве:
        for i in range(len(self._arr)):
            temp_arr[self._arr[i]] += 1

        """
        Прибавляем количество встретившихся элементов, значение которых меньше текущего.
        Например, под текущим индексом 3 у нас встретилось 2 элемента (во входном массиве две тройки),
        а также нам встретились 3 элемента под индексом i - 1 (во входном массиве три двойки).
        В таком случае, сейчас temp_arr[i] содержит количество элементов, не превышающих i (три двойки и две тройки).
        
        Причина range(self._k + 1) описана выше.
        """
        for i in range(1, self._k + 1):
            temp_arr[i] += temp_arr[i - 1]

        """
        Создаем основу для выходного массива и заполняем его, чтобы манипулировать индексами.
        Далее идет эквивалент down_to. Первый параметр len(self._arr) - 1, чтобы корректно обратиться к последнему 
        индексу. Второй параметр = -1, чтобы включить 0 индекс.
        
        temp_arr[self._arr[i]] - 1, поскольку идет обращение к индексу.
        """
        result: List[int] = [0 for _ in range(len(self._arr))]
        for i in range(len(self._arr) - 1, -1, -1):
            result[temp_arr[self._arr[i]] - 1] = self._arr[i]
            temp_arr[self._arr[i]] -= 1

        return result


if __name__ == '__main__':
    array: List[int] = [2, 5, 3, 0, 2, 3, 0, 3]
    sorted_array: List[int] = CountingSorting(arr=array).sort()
    print(sorted_array)
